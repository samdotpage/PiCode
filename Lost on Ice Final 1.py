# Lost on Ice# By Henry Eveleigh and Stephen Horvath, 2013# Version 9from tkinter import *import timeimport winsoundroot = Tk()root.title('Lost on Ice')root.resizable(0,0)root.wm_attributes('-topmost',1)c = Canvas(root,width=500,height=500,bd=0,highlightthickness=0)# From bouncec.pack()# The main Tk object is called root and the canvas is called c.    class Player: # The player.    def __init__(self,c):        self.c = c        self.id = c.create_rectangle(240,240,260,260,fill='red')        self.x = 0        self.y = -1        c.bind_all('<KeyPress-Left>',lambda evt:self.turn(evt,'left'))        c.bind_all('<KeyPress-Right>',lambda evt:self.turn(evt,'right'))        c.bind_all('<KeyPress-Up>',lambda evt:self.turn(evt,'up'))        c.bind_all('<KeyPress-Down>',lambda evt:self.turn(evt,'down'))        # Makes the player turn when the arrow keys are pressed        # (lambda is so that the function can include arguments)        self.crashcount = 0    def turn(self,evt,direction):        # turn changes the x and y movement variables, like in bounce.        if direction == 'left':            self.x = -1            self.y = 0        if direction == 'right':            self.x = 1            self.y = 0        if direction == 'up':            self.x = 0            self.y = -1        if direction == 'down':            self.x = 0            self.y = 1    def draw(self):        self.c.move(self.id,self.x,self.y)        class Fence: # Each wall.    def __init__(self,c,p,x1,y1,x2,y2):        # The arguments are the canvas, the player and the coordinates of the fence.        self.c = c        self.p = p        self.id = c.create_rectangle(x1,y1,x2,y2,fill='black')        self.pos = c.coords(self.id) # Note that pos is the initial position.        self.x1 = x1        self.y1 = y1    def check(self):        global maze        ppos = self.c.coords(self.p.id) # Position of the player        if self.pos[2] >= ppos[0] and self.pos[0] <= ppos[2] and self.pos[1] <= ppos[3] and self.pos[3] >= ppos[1]:            self.p.crashcount += 1            self.c.move(self.p.id,maze.pstartx-ppos[0],maze.pstarty-ppos[1])            self.p.turn(None,maze.pstartd)            time.sleep(0.5)            for i in maze.keys: # Puts the keys and fences back by moving them back into the canvas.                i.pressed = False                if self.c.coords(i.id)[0] == 600:                    self.c.move(i.id, i.pos[0]-600,i.pos[1]-600)                    self.c.move(i.fence.id, i.fence.pos[0]-600, i.fence.pos[1]-600)            class Exit: # Exit to the level.     def __init__(self,c,p,x1,y1,x2,y2):        # The arguments are the canvas, the player and the coordinates of the fence.        self.c = c        self.p = p        self.id = c.create_rectangle(x1,y1,x2,y2,fill='green')        self.pos = c.coords(self.id)    def check(self):        global maze        ppos = self.c.coords(self.p.id) # Position of the player        if self.pos[2] >= ppos[0] and self.pos[0] <= ppos[2] and self.pos[1] <= ppos[3] and self.pos[3] >= ppos[1]:            # If in the same area as the player.            maze.clear()            winsound.Beep(262,500)            winsound.Beep(330,500)            winsound.Beep(392,500)            winsound.Beep(523,500)            # Plays an arpeggio using the winsound module            if maze.number ==1:                maze = Maze(2,c,p,240,240,'left',[Fence(c,p,150,150,350,150),Fence(c,p,350,150,350,350),Fence(c,p,150,350,350,350),Fence(c,p,150,150,150,200),Fence(c,p,150,300,150,350),Fence(c,p,50,300,150,300),Fence(c,p,50,50,50,450),Fence(c,p,50,50,450,50),Fence(c,p,450,50,450,450),Fence(c,p,50,450,450,450),Fence(c,p,250,50,250,150)],Exit(c,p,55,305,145,350),[Key(c,p,295,295,305,305,Fence(c,p,350,150,450,150))],[Teleport(c,p,195,95,205,105,290,90),Teleport(c,p,395,95,405,105,240,240)])            elif maze.number == 2:                maze = Maze(3,self.c,self.p,90,90,'right',[Fence(self.c,self.p,50,50,50,150),Fence(self.c,self.p,50,50,450,50),Fence(self.c,self.p,50,150,405,150),Fence(self.c,self.p,150,50,150,90),Fence(self.c,self.p,250,105,250,150),Fence(self.c,self.p,350,50,350,100),Fence(self.c,self.p,400,100,400,420),Fence(self.c,self.p,450,50,450,450),Fence(self.c,self.p,440,250,450,250),Fence(self.c,self.p,400,350,415,350),Fence(self.c,self.p,150,450,450,450),Fence(self.c,self.p,150,400,400,400),Fence(self.c,self.p,150,400,150,450),Fence(self.c,self.p,250,430,250,450),Fence(self.c,self.p,200,250,300,250),Fence(self.c,self.p,300,200,300,250),Fence(self.c,self.p,300,200,350,200),Fence(self.c,self.p,350,200,350,250),Fence(self.c,self.p,350,250,400,250),Fence(self.c,self.p,350,350,400,350),Fence(self.c,self.p,350,300,350,350),Fence(self.c,self.p,200,300,350,300),Fence(self.c,self.p,200,250,200,300)],Exit(self.c,self.p,155,405,200,445),[Key(self.c,self.p,370,320,380,330,Fence(self.c,self.p,250,400,250,450)),Key(self.c,self.p,320,220,330,230,Fence(self.c,self.p,250,250,250,300))],[Teleport(self.c,self.p,405,355,415,365,315,265),Teleport(self.c,self.p,220,270,230,280,90,90)])            elif maze.number == 3:                maze = Maze(4,self.c,self.p,90,90,'right',[Fence(self.c,self.p,250,50,250,400),Fence(self.c,self.p,225,425,275,425),Fence(self.c,self.p,225,425,225,475),Fence(self.c,self.p,225,475,275,475),Fence(self.c,self.p,275,425,275,475)],Exit(self.c,self.p,245,445,255,455),[],[])                c.create_text(100,100,text='YOU WIN!',fill='red',activefill='orange',font='Helvetica')                c.create_text(100,150,text='Number of crashes: ' + str(self.p.crashcount),fill='purple',font='Times')                c.create_text(110,200,text='Â© Henry Eveleigh & Stephen Horvath abcdefghijklmnopqrstuvwxyz',activefill='gold',font='Symbol')            # Changes the maze to the next one.class Key: # Key. Makes a Fence disappear when touched.    def __init__(self,c,p,x1,y1,x2,y2,fence):        # The last argument is a Fence object.        self.c = c        self.p = p        self.id = c.create_rectangle(x1,y1,x2,y2,fill='gold')        self.pos = c.coords(self.id) # Note that pos is the initial position        self.fence = fence        self.pressed = False # When this becomes True, maze.checkall ignores the fence.    def check(self):        ppos = self.c.coords(self.p.id) # Position of the player        if self.pos[2] >= ppos[0] and self.pos[0] <= ppos[2] and self.pos[1] <= ppos[3] and self.pos[3] >= ppos[1] and c.coords(self.id)[0] != 600:            # The last part is so that it does not move after it goes off the canvas.            self.c.move(self.id,600-self.pos[0],600-self.pos[1]) # This line and the line below move the key and fence off the edge of the canvas ((600,600))            self.c.move(self.fence.id,600-self.fence.pos[0],600-self.fence.pos[1])            self.pressed = True # See comment to line 105.class Teleport: # Teleports the player to newplayerx, newplayery when touched.    def __init__(self,c,p,x1,y1,x2,y2,newplayerx,newplayery):        self.c = c        self.p = p        self.id = c.create_rectangle(x1,y1,x2,y2,fill='cyan')        self.pos = c.coords(self.id)        self.newplayerx = newplayerx        self.newplayery = newplayery    def teleportcheck(self):        ppos = self.c.coords(self.p.id) # Position of the player        if self.pos[2] >= ppos[0] and self.pos[0] <= ppos[2] and self.pos[1] <= ppos[3] and self.pos[3] >= ppos[1]:            self.c.move(self.p.id,self.newplayerx-ppos[0],self.newplayery-ppos[1])            # As in the Fence class.            class Maze: # The levels.    # Arguments: Maze number, canvas, player, player start position and direction,    # list of Fences, an Exit, a list of Keys and a list of Teleports.    def __init__(self,number,c,p,pstartx,pstarty,pstartd,fences,theexit,keys,teleporters):        self.number = number        self.c = c        self.fences = fences        self.theexit = theexit        ppos = self.c.coords(p.id)        self.pstartx = pstartx        self.pstarty = pstarty        self.pstartd = pstartd        c.move(p.id,pstartx-ppos[0],pstarty-ppos[1]) # Moves the player to pstartx,pstarty.        p.turn(None,pstartd) # Makes the player face the right direction.        self.keys = keys        self.teleporters=teleporters    def checkall(self): # Checks every fence, the exit, keys and teleporters.        for i in self.fences:            i.check()        self.theexit.check()        for i in self.keys:            if i.pressed == False: # See comment to line 105.                i.fence.check()            i.check()        for i in self.teleporters:            i.teleportcheck()    def clear(self):        for i in self.fences:            self.c.delete(i.id) # Destroys each fence.        self.c.delete(self.theexit.id) # Destroys the exit.        for i in self.keys:            self.c.delete(i.fence.id) # Destroys keys and fences.            self.c.delete(i.id)        for i in self.teleporters:            self.c.delete(i.id) # Destroys teleporters.p = Player(c)# The player is called p.# The other mazes are in Exit.checkmaze = Maze(1,c,p,240,240,'left',[Fence(c,p,150,350,350,350),Fence(c,p,150,150,150,200),Fence(c,p,150,300,150,350),Fence(c,p,50,300,150,300),Fence(c,p,450,50,450,450),Fence(c,p,50,450,450,450),Fence(c,p,250,50,250,150)],Exit(c,p,55,305,145,350),[],[])while True:    p.draw()    root.update_idletasks()    root.update()    time.sleep(0.01)    maze.checkall()    # Also copied from bounce